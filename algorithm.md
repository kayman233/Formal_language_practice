#Описание алгоритм:

Динамика на стеке, элементами которого являются векторы bool(в данном случае реализовано через int) размера k + 1. 1 в массиве на i-ом месте показывает, если в таком языке есть слово ровно из i букв x. 
Изначально, если обрабатываем букву, то смотрим, является ли оно x-ом, и в зависимости от этого в векторе соответственно ставим 1 на 0 или 1 позицию.
Тогда на каждом шаге мы обновляем значения, если нам встретилась какая-то операция:
"+" аналогичен побитовому сложению
"." на позиции i будет 1, если существовали k(из последнего языка, те в векторе - last) и l(из предпоследнего - second_to_last), т.ч k + l = i и last[k] == second_to_last == 1
"*" в новом языке будет пустое слово и слова, в которых кол-во букв x будет кратно кол-ву букв x в исходном языке
